--- a/stb_image.h	2015-02-28 18:56:21.000000000 +0900
+++ b/stb_image.h	2015-02-28 19:04:54.000000000 +0900
@@ -4642,7 +4642,7 @@
             }
          } else {
             for (i=0; i < (int) s->img_x; ++i) {
-               stbi__uint32 v = (stbi__uint32) (bpp == 16 ? stbi__get16le(s) : stbi__get32le(s));
+               stbi__uint32 v = bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s);
                int a;
                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
@@ -5347,6 +5347,8 @@
    int max_x, max_y;
    int cur_x, cur_y;
    int line_size;
+   int loop_count;
+   int delay;
 } stbi__gif;
 
 static int stbi__gif_test_raw(stbi__context *s)
@@ -5603,8 +5605,9 @@
             } else if (g->flags & 0x80) {
                for (i=0; i < 256; ++i)  // @OPTIMIZE: stbi__jpeg_reset only the previous transparent
                   g->pal[i][3] = 255;
-               if (g->transparent >= 0 && (g->eflags & 0x01))
+               if (g->transparent >= 0 && (g->eflags & 0x01)) {
                   g->pal[g->transparent][3] = 0;
+               }
                g->color_table = (stbi_uc *) g->pal;
             } else
                return stbi__errpuc("missing color table", "Corrupt GIF");
@@ -5620,16 +5623,49 @@
          case 0x21: // Comment Extension.
          {
             int len;
-            if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.
-               len = stbi__get8(s);
+            switch (stbi__get8(s)) {
+            case 0x01: // Plain Text Extension
+               break;
+            case 0x21: // Comment Extension
+               break;
+            case 0xF9: // Graphic Control Extension
+               len = stbi__get8(s); // block size
                if (len == 4) {
                   g->eflags = stbi__get8(s);
-                  stbi__get16le(s); // delay
+                  g->delay = stbi__get16le(s); // delay
                   g->transparent = stbi__get8(s);
                } else {
                   stbi__skip(s, len);
                   break;
                }
+               break;
+            case 0xFF: // Application Extension
+               len = stbi__get8(s); // block size
+               if (len != 11) break;
+               if (stbi__get8(s) != 'N') break;
+               if (stbi__get8(s) != 'E') break;
+               if (stbi__get8(s) != 'T') break;
+               if (stbi__get8(s) != 'S') break;
+               if (stbi__get8(s) != 'C') break;
+               if (stbi__get8(s) != 'A') break;
+               if (stbi__get8(s) != 'P') break;
+               if (stbi__get8(s) != 'E') break;
+               if (stbi__get8(s) != '2') break;
+               if (stbi__get8(s) != '.') break;
+               if (stbi__get8(s) != '0') break;
+               if (stbi__get8(s) != 0x03) break;
+               // loop count
+               switch (stbi__get8(s)) {
+               case 0x00:
+                  g->loop_count = 1;
+                  break;
+               case 0x01:
+                  g->loop_count = stbi__get16le(s);
+                  break;
+               }
+               break;
+            default:
+               break;
             }
             while ((len = stbi__get8(s)) != 0)
                stbi__skip(s, len);
